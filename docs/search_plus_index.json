{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 我将在这里写leetcode题解，使用java Copyright ©gclstart 2020 all right reserved，powered by Gitbook发布时间： 2020-08-07 15:48:05 "},"1-100/1.两数之和.html":{"url":"1-100/1.两数之和.html","title":"1.两数之和","keywords":"","body":"题目描述（简单难度） 解法一：暴力 暴力求解，两层循环 public int[] twoSum(int[] nums, int target) { int[] ans = new int[2]; for (int i = 0; i 时间复杂度：O(n2n^2n​2​​) 空间复杂度：O(1) 解法二：map集合 在解法一中的第二个for循环 for (int j = i + 1; j 我们换个理解方式 sub=target-nums[i]; for(int j=(i+1);j 第二层for循环无非是遍历所有的元素，看哪个元素等于sub，时间复杂度是O(n) 有没有一种方法，不用遍历就可以找到元素里有没有等于sub的？ 利用map集合！！！ 我们可以把数组的每个元素作为map的key，下标作为map的value，为什么不能反过来key-下标，value-元素呢？因为java的HashMap只能通过key找到value，不能通过value找到key，value不是唯一的，key是唯一的。 现在只需判断sub在不在key里面就可以了，而此时的时间复杂度为O(1)。 需要注意的地方是，还需判断找到的元素不是当前元素，因为题目里讲一个元素只能用一次。 public int[] twoSum(int[] nums, int target) { HashMap map = new HashMap<>(); for (int i = 0; i 时间复杂度：比解法一少了一个for循环，降为O(n) 空间复杂度：所谓的空间换时间，这里就能体现出来，开辟了一个hashmap，空间复杂度变为O(n) 解法三：优化 看解法二中，两个 for 循环，他们长的一样，我们当然可以把它合起来。复杂度上不会带来什么变化，变化仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进hashmap里。 public int[] twoSum(int[] nums, int target) { HashMap map = new HashMap<>(); int[] ans = new int[2]; for (int i = 0; i 总结 hashmap的应用，使得时间复杂度从O(n2n^2n​2​​)降为O(n) Copyright ©gclstart 2020 all right reserved，powered by Gitbook发布时间： 2020-08-10 16:37:42 "},"1-100/2.两数相加.html":{"url":"1-100/2.两数相加.html","title":"2.两数相加","keywords":"","body":"题目描述（中等难度） 解法 这道题目可以直接求解，但这里面还是有一点技巧的，尤其是下面三句代码 while (l1 != null || l2 != null || carry > 0) { int x = (l1 == null) ? 0 : l1.val; int y = (l2 == null) ? 0 : l2.val; 即使链表到了最后，继续遍历，把它当作0就好了，不影响结果 另外用一个cur指针记录最后一个节点，用于添加新的节点 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode ans = new ListNode(0); ListNode cur = ans; int carry = 0; while (l1 != null || l2 != null || carry > 0) { int x = (l1 == null) ? 0 : l1.val; int y = (l2 == null) ? 0 : l2.val; int sum = x + y + carry; carry = sum / 10; ListNode node = new ListNode(sum % 10); cur.next = node; cur = node; if (l1 != null) { l1 = l1.next; } if (l2 != null) { l2 = l2.next; } } return ans.next; } 初始化的节点 ans 没有存储值，最后返回 ans 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。 时间复杂度：O(max(m, n))，m 和 n分别表示 l1和 l2 的长度。 空间复杂度：O(max(m, n)) Copyright ©gclstart 2020 all right reserved，powered by Gitbook发布时间： 2020-08-10 09:14:16 "},"1-100/3.无重复字符的最长字串.html":{"url":"1-100/3.无重复字符的最长字串.html","title":"3.无重复字符的最长字串","keywords":"","body":"题目描述（中等难度） 解法一：暴力 暴力求解，找一个最长子串，那么我们用两个循环穷举所有子串，然后再用一个函数判断该子串中有没有重复的字符。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0;//保存当前得到满足条件的子串的最大值 for (int i = 0; i set = new HashSet<>();//初始化 hash set for (int i = start; i 时间复杂度：O(n3n^3n​3​​) 时间复杂度太大了，造成了超时，没有通过leetcode *解法二：滑动窗口 上边的算法中，我们假设当 i 取 0 的时候， j 取 1，判断字符串 str[0,1) 中有没有重复的字符。 j 取 2，判断字符串 str[0,2) 中有没有重复的字符。 j 取 3，判断字符串 str[0,3) 中有没有重复的字符。 j 取 4，判断字符串 str[0,4) 中有没有重复的字符。 做了很多重复的工作，因为如果 str[0,3) 中没有重复的字符，我们不需要再判断整个字符串 str[0,4) 中有没有重复的字符，而只需要判断 str[3] 在不在 str[0,3) 中，不在的话，就表明 str[0,4) 中没有重复的字符。 如果在的话，那么 str[0,5) ，str[0,6) ，str[0,7) 一定有重复的字符，所以此时后边的 j 也不需要继续增加了。i ++ 进入下次的循环就可以了。此时，j不变，不能取j+1。 此时可以理解变成了一个「滑动窗口」。 整体就是橘色窗口在依次向右移动。 判断一个字符在不在字符串中，我们需要遍历整个字符串，遍历需要的时间复杂度就是 O(n)，加上最外层的 i 的循环，总体复杂度就是 O(n2n^2n​2​​)。我们可以继续优化，判断字符在不在一个字符串，我们可以将已有的字符串存到 set 集合里，这样的时间复杂度是 O(1)，总的时间复杂度就变成了 O(n)。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0, i = 0, j = 0; Set set = new HashSet<>(); while (j 时间复杂度：在最坏的情况下，while 循环中的语句会执行 2n 次，例如 abcdefgg，开始的时候 j 一直后移直到到达第二个 g 的时候固定不变 ，然后 i 开始一直后移直到 n ，所以总共执行了 2n 次，时间复杂度为 O(n)。 解法三：hashmap优化 继续优化，我们看上边的算法的一种情况。 当 j 指向的 c 存在于前边的子串 abcd 中，此时 i 向前移到 b ,此时子串中仍然含有 c，还得继续移动，所以这里其实可以优化。我们可以一步到位，直接移动到子串 c 的位置的下一位！ 实现这样的话，我们将 set 改为 map ，将字符存为 key ，将对应的下标存到 value 里就实现了。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0; Map map = new HashMap<>(); for (int i = 0, j = 0; j 与解法二相比 ① 这里为什么没有remove掉map之前存的字符，因为 if 语句中进行了Math.max(map.get(s.charAt(j)) + 1, i)，可以保证得到的下标不是 i 前面的 ② j 每次循环都进行了自加 1 ，因为 i 的跳跃已经保证了 str[ i , j] 内没有重复的字符串，所以 j 直接可以加 1 。而解法二中，如果子串中包含字符，要保持 j 的位置不变，因为不知道和 j 重复的字符在哪个位置。 ③ ans 在每次循环中都进行更新，因为 ans 更新前 i 都进行了更新，已经保证了当前的子串符合条件，所以可以更新 ans 。而解法二中，只有当当前的子串不包含当前的字符时，才进行更新。 ④ map的put方法会覆盖原来存在的值，执行下面的代码，最后得到的是6。这样就可以保存字符最新的位置 map.put('a',3); map.put('a',6); map.get('a'); //6 时间复杂度：我们将 2n 优化到了 n ，但最终还是和之前一样，O（n）。 解法四：数组 和解法三思路一样，区别的地方在于，我们不用 map，而是直接用数组，字符的 ASCII 码值作为数组的下标，数组存储该字符所在字符串的位置。适用于字符集比较小的情况，因为我们会直接开辟和字符集等大的数组。 public int lengthOfLongestSubstring(String s) { int n = s.length(); int ans = 0; int[] arr = new int[128]; //存放字符所在字符串的位置，字符的 ASCII 码值对应下标 for (int i = 0, j = 0; j 和解法 3 不同的地方在于，没有了 if 的判断，因为如果 index[ s.charAt ( j ) ] 不存在的话，它的值会是 0 ，对最终结果不会影响。 时间复杂度：O（n）。 Copyright ©gclstart 2020 all right reserved，powered by Gitbook发布时间： 2020-08-10 16:45:02 "}}